<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Builds on raph haXx </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://raph.es/tags/builds/index.xml/</link>
    
    
    <copyright>Raphael Estrada 2011-2014</copyright>
    <updated>Thu, 15 Mar 2012 21:37:00 &#43;0100</updated>
    
    <item>
      <title>Teenage Mutant Ninja Unit-Tests</title>
      <link>http://raph.es/blog/2012/03/Teenage-Mutant-Ninja-Unit-Tests/</link>
      <pubDate>Thu, 15 Mar 2012 21:37:00 &#43;0100</pubDate>
      
      <guid>http://raph.es/blog/2012/03/Teenage-Mutant-Ninja-Unit-Tests/</guid>
      <description>

&lt;p&gt;When you are testing something - anything - you have some expectations as to what the result should be. The result either matches your expectations, or it does not. For example, you might want to find out what the person next to you will do if you shoot her in the face with a &lt;a href=&#34;http://www.youtube.com/watch?v=IZRQ1WkWFoU&#34;&gt;humble Nerf gun&lt;/a&gt;. Will she laugh? Shoot back? Kick your ass?&lt;/p&gt;

&lt;p&gt;Many factors can affect the outcome of this test. Her current mood. Her &lt;a href=&#34;http://www.youtube.com/watch?v=HUD6sBrPB30#t=0m50s&#34;&gt;attitude toward being shot in the face&lt;/a&gt;. The exact position where you hit her (cheek vs. eye). The frequency at which you repeat the test. What she was busy doing before the fact and how much you surprise her. Who&amp;rsquo;s watching can affect how embarrassed she will be. Bottom line: each time you perform the test, the &lt;em&gt;variables&lt;/em&gt; will &lt;em&gt;vary&lt;/em&gt; (get it? get it?). And the results can be different given the changing conditions.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Isolate your tests&lt;/h1&gt;

&lt;p&gt;You want a test to provide a reliable result each time. Because the alternative would mean you cannot trust single results, and may have to resort to averaging the results of many individual test runs. That&amp;rsquo;s unnecessary extra work and should be avoided.&lt;/p&gt;

&lt;p&gt;You cannot guarantee reliable results if you do not control all the variables and moving parts of your test. Especially when they require human involvement, there&amp;rsquo;s always the chance that somebody does things in a slightly different order or timing. The slightest deviation from the other runs can affect the outcome and should make you distrust the results. This is one of the main reasons why software testing should be automated as far as possible, if not entirely.&lt;/p&gt;

&lt;p&gt;So with that in mind, you&amp;rsquo;ve written some tests. They use a testing framework that has &amp;ldquo;unit&amp;rdquo; in it&amp;rsquo;s name, which means that they are unit tests. Right? Try again. Unit tests are supposed to focus on the behavior of a particular unit, nothing more and nothing less. Definitions of &amp;ldquo;unit&amp;rdquo; may vary, but it&amp;rsquo;s often a class. If unit tests are not properly &lt;em&gt;isolated&lt;/em&gt;, they will have more dependencies than are necessary for what you are trying to test. More moving parts. More things you need to control, but often can&amp;rsquo;t. More things that are going to void your test results.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Teenage Mutant Ninja Unit-Tests&lt;/h1&gt;

&lt;p&gt;Tests that execute differently each time they run are called &lt;a href=&#34;http://www.typemock.com/rule-avoid-time-mutating-tests&#34;&gt;&lt;em&gt;mutating tests&lt;/em&gt;&lt;/a&gt;. Dependencies that can skew your results are often inputs that they do not entirely &amp;ldquo;own&amp;rdquo;, e.g. values from a database or shared files on a network. If those values change, your test changes.&lt;/p&gt;

&lt;p&gt;There are also rather less obvious mutagens that can have the same effect, for example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;threading: dependency on CPU performance and the operating system&amp;rsquo;s thread scheduling&lt;/li&gt;
&lt;li&gt;environment variables: can be different on other machines, for other users&lt;/li&gt;
&lt;li&gt;run-time dynamic linking: another machine could have a different version of some DLL in the GAC&lt;/li&gt;
&lt;li&gt;time: e.g. &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/system.datetime.now.aspx&#34;&gt;&lt;code&gt;DateTime.Now&lt;/code&gt;&lt;/a&gt; will be different every time your test runs&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Mutation_testing&#34;&gt;Mutation testing&lt;/a&gt; can in fact be a way to test your tests. Modify the logic-under-test and you should see some of your tests fail. This practice appears to be rather academic as I still have to come across somebody who actually &lt;em&gt;uses&lt;/em&gt; mutation testing in the real world.&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;A recent example&lt;/h1&gt;

&lt;p&gt;The problem with mutating tests is that you only notice them when they fail. This is worrying as it makes you wonder how many tests are mutating in ways that &lt;em&gt;prevent&lt;/em&gt; them from failing when the actually should&amp;hellip; In the following recent real-life case, two tests were failing even though there were no changes to the code.&lt;/p&gt;

&lt;figure &gt;
    
    &lt;figcaption&gt;
        &lt;p&gt;
        WTF?
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
    &lt;p&gt;&lt;a href=&#34;/img/blogger/negative-tickcount-teamcitytests.jpeg&#34;&gt;
  &lt;img src=&#34;/img/blogger/negative-tickcount-teamcitytests.jpeg&#34;  alt=&#34;tests fail even though code did not change&#34; width=&#34;300em&#34;  /&gt;
  &lt;/a&gt;&lt;/p&gt;

&lt;/figure&gt;

&lt;div class=&#34;clearboth&#34;&gt;&lt;/div&gt;

&lt;p&gt;When I ran the same tests from the same version of the code locally on my machine, they passed. My spider-senses tingled: mutating tests! After looking at the build times I noticed that they began failing on March 12, and since then consistently failed. That indicates a temporal dependency.&lt;/p&gt;

&lt;p&gt;After some investigation I discovered that the code-under-test used the .NET property &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/system.environment.tickcount%28v=vs.100%29.aspx&#34;&gt;&lt;code&gt;Environment.TickCount&lt;/code&gt;&lt;/a&gt; to capture points in time and compare them. TickCount is an Integer and counts the milliseconds since the host machine was started. It starts at 0, counts up to 2147483647 (= &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/system.int32.maxvalue.aspx&#34;&gt;&lt;code&gt;Int.MaxValue&lt;/code&gt;&lt;/a&gt;), then wraps around to -2147483648 (= &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/system.int32.minvalue.aspx&#34;&gt;&lt;code&gt;Int.MinValue&lt;/code&gt;&lt;/a&gt;) and goes up towards 0 again.&lt;/p&gt;

&lt;p&gt;The code-under-test compared the TickCount value against a fake count of 1. The difference determined the outcome of the test. It was positive until the TickCount went beyond Int.MaxValue and wrapped into the negative - where it suddenly turns into a very negative one.&lt;/p&gt;

&lt;p&gt;I did some very complicated math to find out how long a machine would have to run until the TickCount reaches Int.MaxValue:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2147483647ms / 1000ms  / 60s / 60min / 24hr =  ~24.86 days
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Typically I will reboot my dev machine every few days, but the build agents often run for weeks without a reboot. That would explain why the tests pass on my machine, but not on the build server.&lt;/p&gt;

&lt;p&gt;Enough of the theories, let&amp;rsquo;s have some proof. TeamCity can show you when an agent has registered with the server - which I know will happen automatically every time the agent host boots up.&lt;/p&gt;

&lt;figure &gt;
    
    &lt;figcaption&gt;
        &lt;p&gt;
        When did my build agent last reboot?
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
    &lt;p&gt;&lt;a href=&#34;/img/blogger/negative-tickcount-teamcityagentinfo.jpeg&#34;&gt;
  &lt;img src=&#34;/img/blogger/negative-tickcount-teamcityagentinfo.jpeg&#34;  alt=&#34;checking the agent restart time on TeamCity&#34; width=&#34;400em&#34;  /&gt;
  &lt;/a&gt;&lt;/p&gt;

&lt;/figure&gt;

&lt;div class=&#34;clearboth&#34;&gt;&lt;/div&gt;

&lt;p&gt;So it started up on Feb 15. That&amp;rsquo;s just about exactly 25 days before the tests started to fail. The TickCount must have wrapped into the negative. So there&amp;rsquo;s one more thing to do to prove it: using PowerShell you can call that same TickCount property and see what value it has. And sure enough&amp;hellip;&lt;/p&gt;

&lt;figure &gt;
    
    &lt;figcaption&gt;
        &lt;p&gt;
        PowerShell gives you direct access to .NET methods
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
    &lt;p&gt;&lt;a href=&#34;/img/blogger/negative-tickcount-cropped.jpeg&#34;&gt;
  &lt;img src=&#34;/img/blogger/negative-tickcount-cropped.jpeg&#34;  alt=&#34;Invoking Environment.TickCount using PowerShell&#34;   /&gt;
  &lt;/a&gt;&lt;/p&gt;

&lt;/figure&gt;

&lt;div class=&#34;clearboth&#34;&gt;&lt;/div&gt;

&lt;p&gt;All that had to be done now is reboot the build servers, and the tests passed fine again!&lt;/p&gt;

&lt;p&gt;Not.&lt;/p&gt;

&lt;p&gt;We stubbed out the call to &lt;code&gt;Environment.TickCount&lt;/code&gt; so we can control it in the tests, better isolating them from the environment.&lt;/p&gt;

&lt;p&gt;And now the world is a little bit safer.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Revisited: Mapping network drives for TeamCity build agents</title>
      <link>http://raph.es/blog/2011/12/Revisited-Mapping-network-drives-for-TeamCity-build-agents/</link>
      <pubDate>Mon, 19 Dec 2011 06:58:00 &#43;0100</pubDate>
      
      <guid>http://raph.es/blog/2011/12/Revisited-Mapping-network-drives-for-TeamCity-build-agents/</guid>
      <description>

&lt;p&gt;In an older &lt;a href=&#34;/2011/06/mapping-network-drives-for-teamcity.html&#34;&gt;post&lt;/a&gt; I mentioned how hard it is to have TeamCity agents have access to mapped drives. Unfortunately, Windows only maps network drives during a user&amp;rsquo;s login process. But you do not want to log in for every build agent - ideally they will run as daemons and, for instance, start automatically when the system boots without a user having to get involved.&lt;/p&gt;

&lt;p&gt;So what I did before was an ugly hack - I used &lt;a href=&#34;http://technet.microsoft.com/en-us/sysinternals/bb897553&#34;&gt;psexec&lt;/a&gt; to map the drives I want agents to see to the root user (&amp;ldquo;SYSTEM&amp;rdquo;). I never really understood why it worked, but I never liked the solution. Plus, it still did not give you a real Windows service, only a scheduled task that sort of behaved the same way.&lt;/p&gt;

&lt;p&gt;I recently did some reworking of my agents and decided to get rid of the psexec hack. What I did this time is much simpler: I gave up. Yep, I gave up trying to map the drives for the agents. If I want agents to be services, and services cannot map drives, so be it.&lt;/p&gt;

&lt;figure &gt;
    
    &lt;p&gt;&lt;a href=&#34;/img/blogger/troll-mappings.jpeg&#34;&gt;
  &lt;img src=&#34;/img/blogger/troll-mappings.jpeg&#34;   width=&#34;400em&#34;  /&gt;
  &lt;/a&gt;&lt;/p&gt;

&lt;/figure&gt;

&lt;div class=&#34;clearboth&#34;&gt;&lt;/div&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Work with it, not against it&lt;/h1&gt;

&lt;p&gt;The alternative is to not need drive mappings in the first place. It crossed my mind that I might want to force all reference paths in the VS projects to be UNC paths. Problem is when you add a new file or reference, VS defaults to the drive letter and not the UNC path. Builds would regularly break because somebody forgot to manually change it into a UNC path&amp;hellip;not cool.&lt;/p&gt;

&lt;p&gt;The simple way around this is have a build step run before each VS compile that &amp;ldquo;unmaps&amp;rdquo; the project files automagically. Devs can still use drive mappings which work for them and don&amp;rsquo;t have to worry about these build server specifics.&lt;/p&gt;

&lt;p&gt;At the end of this post is a simple Powershell script that does the job. It&amp;rsquo;s quite simple in that it does a find/replace using regular expressions. Turns out this works quite nicely and performs well, too - just a few seconds to process several hundreds of project files. Adding in target file types or drive mappings should be straight-forward. Feel free to use, but &lt;em&gt;please read and respect the &lt;a href=&#34;/license&#34;&gt;license&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Running it as a pre-build step&lt;/h1&gt;

&lt;p&gt;On TeamCity 6+ you can configure an arbitrary chain of build steps. Just have TeamCity run this script on before your projects are compiled. Simplest is to just pass in the builds working directory as a paramter (&lt;code&gt;%system.teamcity.build.workingDir%&lt;/code&gt;). That way you can replace the drive mappings in all files that were checked out of source control for the running build. You can, of course, use more specific paths instead of this shotgun approach. If that&amp;rsquo;s how you roll.&lt;/p&gt;

&lt;p&gt;Keep in mind that your build machines will by default have a &lt;a href=&#34;http://technet.microsoft.com/en-us/library/dd347628.aspx&#34;&gt;PowerShell execution policy&lt;/a&gt; of &lt;code&gt;Restricted&lt;/code&gt;. You&amp;rsquo;ll have to change it to run the scripts. &lt;code&gt;Set-ExecutionPolicy RemoteSigned&lt;/code&gt; will do. If you TC process runs with administrator privileges you can also pass in a parameter to powershell.exe that will bypass the execution policy (use at your own risk):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;powershell.exe .\myscript.ps1 &amp;lt;path&amp;gt; -executionPolicy Bypass. 
&lt;/code&gt;&lt;/pre&gt;

&lt;figure &gt;
    
    &lt;p&gt;&lt;a href=&#34;/img/blogger/tc-unmap-drives-step-highlight.jpeg&#34;&gt;
  &lt;img src=&#34;/img/blogger/tc-unmap-drives-step-highlight.jpeg&#34;   width=&#34;350em&#34;  /&gt;
  &lt;/a&gt;&lt;/p&gt;

&lt;/figure&gt;

&lt;div class=&#34;clearboth&#34;&gt;&lt;/div&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Example script (PowerShell)&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;# licensed under The MIT license: http://www.opensource.org/licenses/mit-license.php
# Copyright (c) Raphael Estrada
# Author URL: http://www.galaktor.net
PARAM([parameter(Mandatory = $true)]
      [string]$root=$(throw &amp;quot;Must give a root path.&amp;quot;))

$exitCode = 0

try
{
  $stopWatch = New-Object &amp;quot;System.Diagnostics.Stopwatch&amp;quot;
  $stopWatch.Start()
  # works on C# an VC++ project files
  $targetFiles = Get-ChildItem $root -recurse -include @(&amp;quot;*.csproj&amp;quot;,&amp;quot;*.vcxproj&amp;quot;)
  $stopWatch.Stop()

  Write-Host &amp;quot;Finding&amp;quot; $targetFiles.Length &amp;quot;files took&amp;quot; $stopWatch.ElapsedMilliseconds &amp;quot;ms&amp;quot;

  $mappings = @(
          (&#39;X&#39;, &#39;\\path\to\x&#39;),
          (&#39;Y&#39;, &#39;\\path\to\y&#39;),
          (&#39;Z&#39;, &#39;\\path\to\z&#39;)
        )

  $stopWatch.Reset()
  $stopWatch.Start()
  $modifiedCounter = 0
  foreach($file in $targetFiles)
  {
    # project file XML is usually UTF8
    $content = (Get-Content $file -Encoding UTF8)

    foreach($mapping in $mappings)
    {
      $pathRegex = [System.String]::Format(&amp;quot;{0}:\\&amp;quot;, $mapping[0])
      $replacement = $mapping[1]
      if(!$replacement.EndsWith(&amp;quot;\&amp;quot;))
      {
        $replacement += &amp;quot;\&amp;quot;
      }
      if($content -match $pathRegex)
      {
        Write-Host &amp;quot;Found references to&amp;quot; $mapping[0] &amp;quot;drive in&amp;quot; $file.FullName &amp;quot;- Replacing with&amp;quot; $mapping[1]
        $content = $content -replace $pathRegex, $replacement
        $modifiedCounter++
      }
    }

    # write result back to file; again UTF8
    Set-Content -Encoding UTF8 $file $content -Force
  }
  $stopWatch.Stop()

  Write-Host &amp;quot;Processing&amp;quot; $targetFiles.Length &amp;quot;files took&amp;quot; $stopWatch.ElapsedMilliseconds &amp;quot;ms&amp;quot;
  Write-Host &amp;quot;Files modified:&amp;quot; $modifiedCounter
}
catch [System.Exception]
{
  Write-Host &amp;quot;ERROR!&amp;quot; $_ -ForegroundColor Red
  $exitCode = 1
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Mapping network drives for TeamCity build agents</title>
      <link>http://raph.es/blog/2011/06/Mapping-network-drives-for-TeamCity-build-agents/</link>
      <pubDate>Sun, 12 Jun 2011 20:18:00 &#43;0100</pubDate>
      
      <guid>http://raph.es/blog/2011/06/Mapping-network-drives-for-TeamCity-build-agents/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Update&lt;/em&gt;: I recently changed my solution to the below problem. Go &lt;a href=&#34;/2011/12/revisited-mapping-network-drives-for.html&#34;&gt;check out&lt;/a&gt; my new, revolutionary approach to drive mappings on TeamCity agents!&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.jetbrains.com/teamcity/ is a sophisticated and, above all, easy-to-use [CI server](http://en.wikipedia.org/wiki/Continuous_integration&#34;&gt;TeamCity&lt;/a&gt;. It works equally well on different platforms, and despite it being implemented in Java, has surprisingly good support for Windows and .NET development.&lt;/p&gt;

&lt;p&gt;When you install TeamCity, aside from the central (web) server, you will be running at least one build agent. On Windows, it is very convenient to install agents as &lt;a href=&#34;http://en.wikipedia.org/wiki/Windows_service&#34;&gt;NT services&lt;/a&gt;. That way they can run &lt;a href=&#34;http://en.wikipedia.org/wiki/Daemon_%28computer_software%29&#34;&gt;daemon-like&lt;/a&gt; in the background, unattended, and without having to log on as an actual user of the build machine. Especially when your machines can be restarted frequently (e.g. for updates), it comes in handy that the service will simply start up again after the reboot.&lt;/p&gt;

&lt;p&gt;There is one annoying fact about Windows services, though: they will not see &lt;a href=&#34;http://en.wikipedia.org/wiki/Network_share&#34;&gt;network drive mappings&lt;/a&gt;. If your code base happens to have references to shared libraries on the network, and you use mapped drive letters to point your code to those (as opposed to, say, UNC paths), your builds will fail when running the build agent as a service. It will not see mapped drives, and therefor not find your dependencies.&lt;/p&gt;

&lt;p&gt;I am no hardcore Windows administrator, but it appears that the network drive mapping is bound to a user and to his security context. That allows windows to decide, for example, if the mapped drive can be accessed by whatever user is currently logged on. No user, no security context, no mapped drives. What is particularly weird is that this still happens when you tell Windows to run the service as a particular user (instead of the default SYSTEM user).&lt;/p&gt;

&lt;p&gt;Anyhoo, feel free to google the hell out of this topic and please leave a comment if you find a way to legally tell a service to map some drives. Until then, I have come up with a similar approach that will give you the benefits of a service without actually using it. It is hacky, I admit that much, and I do not understand every geeky detail of why it works while the service can&amp;rsquo;t see the network drives&amp;hellip;but I feel I should dump my hack here in case anyone finds himself in a similar situation and just wants it to &lt;em&gt;work&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Mapping drives to the root&lt;/h1&gt;

&lt;p&gt;I have done the following on Windows Server 2008 R2 machines - it goes without saying (but I&amp;rsquo;ll still say it) that these steps might differ or not work at all on other versions of Windows. Again, if you know a better way, I&amp;rsquo;m all ears.&lt;/p&gt;

&lt;p&gt;First of all, we need a script that contains the commands to map the drives you need during your builds. As an example, I will assume you want a drive X: to point to a location on your network, \someserver\some\directory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;REM content of &amp;quot;map_network_drives.cmd&amp;quot;

REM delete existing mapping first
net use x: /delete

REM map drive; &amp;quot;persistent&amp;quot; just in case
net use x: \\someserver\some\directory /persistent:yes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, using the almighty &lt;a href=&#34;http://technet.microsoft.com/en-us/sysinternals/bb897553&#34;&gt;PsExec&lt;/a&gt;, part of the &lt;a href=&#34;http://technet.microsoft.com/en-us/sysinternals/bb842062&#34;&gt;Sysinternals Suite&lt;/a&gt;, we create another script that will call our previous network map script with as the &amp;ldquo;root&amp;rdquo; user of your windows machine, the SYSTEM account. Note that screwing around with the root account can be a dangerous thing to do - don&amp;rsquo;t say I did not warn you.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;REM content of &amp;quot;system_map_network_drives.cmd&amp;quot;

REM configure locations to dependencies 
set psexecPath=C:\tools\PsTools\PsExec.exe
set mapNetworkDrives=C:\tools\map_network_drives.cmd 

REM map network drives to SYSTEM user 
%psexecPath% -s %mapNetworkDrives%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, in order to imitate a service&amp;rsquo;s behavior, we need a scheduled task that will execute our &lt;code&gt;system_map_network_drives.cmd&lt;/code&gt; script on &lt;em&gt;system startup&lt;/em&gt;. Make sure the task is setup to run as an administrator. For details on how to schedule a task in windows, check out this &lt;a href=&#34;http://en.lmgtfy.com/?q=scheduled+task+windows&#34;&gt;radical new website that will answer virtually all of your questions&lt;/a&gt;. For each of your TeamCity agents, set up a task the same way at system start-up that will execute &lt;code&gt;agent.bat start&lt;/code&gt; (located in your build agent&amp;rsquo;s &lt;code&gt;bin&lt;/code&gt; directory).&lt;/p&gt;

&lt;p&gt;What will happen now is whenever your machine boots up, your agents will start up, and in parallel, your SYSTEM account will have the expected drive mappings. When your agents start building, they will be able to resolve the mapped drive paths in your code at compile time.&lt;/p&gt;

&lt;p&gt;Now you might be wondering why I don&amp;rsquo;t just do the same and start the agents as services instead of tasks. That did not work - for &lt;em&gt;me&lt;/em&gt; at least. Although tasks seem to have the same limitations regarding drive mappings as the services do, for some reason, giving the SYSTEM user those drive mappings works for the tasks, but not the services. As I said, I&amp;rsquo;m no Windows guru, and to be honest I was just plain happy this worked eventually.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Verifying the mapped drives&lt;/h1&gt;

&lt;p&gt;When you call PsExec for the first time, you will need an elevated command prompt so it can install the PsExec service. And you&amp;rsquo;ll need to accept the terms and conditions at first run as well. You can verify this by using PsExec to get a console and checking if the drives are mapped, as shown below. Before running the above tasks, the call to &lt;code&gt;net use&lt;/code&gt; will inform you that &lt;code&gt;&amp;quot;There are no entries in the list.&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\tools\PsTools&amp;gt;PsExec.exe -s cmd.exe
PsExec v1.98 - Execute processes remotely
Copyright (C) 2001-2010 Mark Russinovich
Sysinternals - www.sysinternals.com


Microsoft Windows [Version 6.1.7600]
Copyright (c) 2009 Microsoft Corporation.  All rights reserved.

C:\Windows\system32&amp;gt;whoami
nt authority\system

C:\Windows\system32&amp;gt;net use
New connections will be remembered.

Status       Local     Remote                       Network

----------------------------------------------------------------------------------
OK           X:        \\someserver\some\directory  Microsoft Windows Network
The command completed successfully.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s worth mentioning that this approach might cause problems when the mapped network location requires specific permissions - adding the &amp;ldquo;SYSTEM&amp;rdquo; for every build machine to permission lists is not very scalable, especially when you have lots of build boxes in a farm.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Conditional References in Visual Studio projects</title>
      <link>http://raph.es/blog/2011/05/Conditional-References-in-Visual-Studio-projects/</link>
      <pubDate>Thu, 05 May 2011 08:42:00 &#43;0100</pubDate>
      
      <guid>http://raph.es/blog/2011/05/Conditional-References-in-Visual-Studio-projects/</guid>
      <description>

&lt;p&gt;Visual Studio does a good job in hiding the MSBuild configurations from it&amp;rsquo;s users. MSBuild is quite flexible and powerful - but the VS user interface only gives you control over a tiny piece of it. One handy feature I believe deserves more attention in the IDE is &lt;em&gt;conditional references&lt;/em&gt;. When you add a reference to one of your projects, by default it will be static. No matter how you &lt;a href=&#34;/2011/04/targeting-platforms-in-visual-studio.html&#34;&gt;modify your solution configuration or platform settings&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But some libraries are platform dependent. If you build your solution as 64bit, you will not want to use a version of a library that is restricted to 32bit platforms. Visual Studio does not give you a way to put conditions on your references. Fortunately, MSBuild does. When referencing an assembly in VS, a &lt;code&gt;Reference&lt;/code&gt; (or &lt;code&gt;ProjectReference&lt;/code&gt;) element is added to your project file&amp;rsquo;s XML containing details of the assembly and a &lt;code&gt;HintPath&lt;/code&gt; to it&amp;rsquo;s (supposed) location.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Reference Include=&amp;quot;MyAssembly, processorArchitecture=MSIL&amp;quot;&amp;gt;
    &amp;lt;SpecificVersion&amp;gt;False&amp;lt;/SpecificVersion&amp;gt;
    &amp;lt;HintPath&amp;gt;path\to\MyAssembly.dll&amp;lt;/HintPath&amp;gt;
&amp;lt;/Reference&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Setting the conditions&lt;/h1&gt;

&lt;p&gt;Using your favorite text editor, you can add a &lt;code&gt;Condition&lt;/code&gt; attribute to any reference in your project file, telling MSBuild when to use it (or not). This allows you to reference assemblies of different architecture and make sure they are used according to which platform you are targeting. In this case, a reference could look like the following in your project file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Reference Include=&amp;quot;MyAssembly, processorArchitecture=MSIL&amp;quot;
           Condition=&amp;quot;&#39;$(Platform)&#39; == &#39;x86&#39;&amp;quot;&amp;gt;
    &amp;lt;SpecificVersion&amp;gt;False&amp;lt;/SpecificVersion&amp;gt;
    &amp;lt;HintPath&amp;gt;path\to\32bit\MyAssembly.dll&amp;lt;/HintPath&amp;gt;
&amp;lt;/Reference&amp;gt;
&amp;lt;Reference Include=&amp;quot;MyAssembly, processorArchitecture=MSIL&amp;quot; 
           Condition=&amp;quot;&#39;$(Platform)&#39; == &#39;x64&#39;&amp;quot;&amp;gt;
    &amp;lt;SpecificVersion&amp;gt;False&amp;lt;/SpecificVersion&amp;gt;
    &amp;lt;HintPath&amp;gt;path\to\64bit\MyAssembly.dll&amp;lt;/HintPath&amp;gt;
&amp;lt;/Reference&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works because in MSBuild the reference elements are &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ms164283%28v=VS.100%29.aspx&#34;&gt;&lt;code&gt;Item&lt;/code&gt; elements&lt;/a&gt;. Many element types can have condition attributes. If you look at other parts of your project file you will probably see that the project configuration and platform sections also use conditions similar to the above example. There are &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ms164307.aspx&#34;&gt;other ways to define conditional logic in MSBuild&lt;/a&gt;, but this is probably the quickest and most understandable. If you plan to do more funky stuff, have a look at &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ms164282.aspx&#34;&gt;&lt;code&gt;&amp;lt;Choose&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;Otherwise&amp;gt;&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;figure &gt;
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Condition evaluates to *False*
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
    &lt;p&gt;&lt;a href=&#34;/img/blogger/reference-warning.jpeg&#34;&gt;
  &lt;img src=&#34;/img/blogger/reference-warning.jpeg&#34;   width=&#34;200em&#34;  /&gt;
  &lt;/a&gt;&lt;/p&gt;

&lt;/figure&gt;

&lt;div class=&#34;clearboth&#34;&gt;&lt;/div&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;The &lt;code&gt;Platform&lt;/code&gt; variable&lt;/h1&gt;

&lt;p&gt;Note that in my example I am querying the &lt;code&gt;Platform&lt;/code&gt; variable - &lt;em&gt;not&lt;/em&gt; &lt;code&gt;Configuration&lt;/code&gt;. I have noticed a practice &lt;a href=&#34;http://dev.monogram.sk/websvn/filedetails.php?repname=graphstudio&amp;amp;path=%2Ftrunk%2Fgraphstudio.sln&#34;&gt;on teh webz&lt;/a&gt; that suggests you create new configurations named &lt;em&gt;Debug64&lt;/em&gt; and &lt;em&gt;Release64&lt;/em&gt;, then switch references based on the &lt;code&gt;Configuration&lt;/code&gt; variable. While this technically works the same way, it is logically incorrect. &lt;code&gt;Configuration&lt;/code&gt; and &lt;code&gt;Platform&lt;/code&gt; settings are two different concerns in Visual Studio and it is unwise to mix them. It&amp;rsquo;s messy, redundant and generates loads of unnecessary lines in your solution and project files.&lt;/p&gt;

&lt;p&gt;Assuming that your project has nicely &lt;a href=&#34;http://en.wikipedia.org/wiki/Separation_of_concerns&#34;&gt;separated concerns&lt;/a&gt; you should not have to make this change in more than one or &lt;a href=&#34;http://en.wikipedia.org/wiki/Rule_of_three_%28programming%29&#34;&gt;three&lt;/a&gt; places. If you &lt;em&gt;are&lt;/em&gt; facing a large number of projects that need this additional logic, this XML operation can easily be automated via a script or macro.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Targeting Platforms in Visual Studio</title>
      <link>http://raph.es/blog/2011/04/Targeting-Platforms-in-Visual-Studio/</link>
      <pubDate>Tue, 12 Apr 2011 19:16:00 &#43;0100</pubDate>
      
      <guid>http://raph.es/blog/2011/04/Targeting-Platforms-in-Visual-Studio/</guid>
      <description>

&lt;p&gt;None of Visual Studio&amp;rsquo;s features is more essential than compiling text to binary assemblies - in VS terminology: &amp;ldquo;building&amp;rdquo;. Since this is the single most important task you use an IDE for, it is crucial that you understand how it works if you want to have more control over what you build, and especially for what target platform - e.g. when automating your builds for continuous integration.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Configuration != Configuration&lt;/h1&gt;

&lt;figure &gt;
    
    &lt;figcaption&gt;
        &lt;p&gt;
        L: Solution configuration; R: Solution platform
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
    &lt;p&gt;&lt;a href=&#34;/img/blogger/configuration_platform_selector.jpeg&#34;&gt;
  &lt;img src=&#34;/img/blogger/configuration_platform_selector.jpeg&#34;     /&gt;
  &lt;/a&gt;&lt;/p&gt;

&lt;/figure&gt;

&lt;div class=&#34;clearboth&#34;&gt;&lt;/div&gt;

&lt;p&gt;The &lt;em&gt;solution configuration&lt;/em&gt; and &lt;em&gt;solution platform&lt;/em&gt; selectors are two of the most used and at the same time most misunderstood UI elements in Visual Studio. You would think that they allowed you to define with which configuration and for which target platform your code will be compiled. What users &lt;em&gt;expect&lt;/em&gt; is this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SLN config + SLN platform =&amp;gt; Binary
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately, it is not that simple. There is a chain of five independent variables that define how a single project in your solution will be compiled. The solution configuration/platform settings from the VS toolbar are the first two. As a pair, they determine which project configuration and platform settings will be used to build a project. Those two then eventually define which &lt;em&gt;platform target&lt;/em&gt; the compiler will use to eventually create your assembly. Change any of those variables and you can end up with an entirely different value for &amp;ldquo;platform target&amp;rdquo; when building your solution. So in reality, your chain of platform configuration looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SLN config + SLN platform =&amp;gt; PROJ config + PROJ platform =&amp;gt; PROJ platform target =&amp;gt; Binary
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I will attempt to shed some light on the different parts of this chain and present a way - well, &lt;em&gt;my&lt;/em&gt; way - of dealing with it&amp;rsquo;s complexity in order to regain control of this process. I am going to roll up this chain from the end.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Project configurations&lt;/h1&gt;

&lt;p&gt;A project in Visual Studio represents a binary that will be generated after compilation. As you would expect, the &lt;em&gt;project settings&lt;/em&gt; window allows you to define &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/0hkyezwy%28v=VS.100%29.aspx&#34;&gt;various options&lt;/a&gt; around that binary - most notably where the file will be copied to, if the compiler will optimize the generated IL (i.e. in Release mode) and what platform architecture you are targeting. Those settings are stored in a &lt;em&gt;project file&lt;/em&gt;.&lt;/p&gt;

&lt;figure &gt;
    
    &lt;figcaption&gt;
        &lt;p&gt;
        *Platform* !=*Platform target* o_O
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
    &lt;p&gt;&lt;a href=&#34;/img/blogger/project_settings.jpeg&#34;&gt;
  &lt;img src=&#34;/img/blogger/project_settings.jpeg&#34;   width=&#34;500em&#34;  /&gt;
  &lt;/a&gt;&lt;/p&gt;

&lt;/figure&gt;

&lt;div class=&#34;clearboth&#34;&gt;&lt;/div&gt;

&lt;p&gt;Project files are essentially just &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/5dy88c2e.aspx&#34;&gt;XML(ish) input files&lt;/a&gt; for a tool called &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/wea2sca5%28v=vs.90%29.aspx&#34;&gt;MSBuild&lt;/a&gt;. It is Microsoft&amp;rsquo;s build tool, logically very similar to &lt;a href=&#34;http://nant.sourceforge.net/&#34;&gt;NAnt&lt;/a&gt; and &lt;a href=&#34;http://en.wikipedia.org/wiki/Build_automation&#34;&gt;the likes&lt;/a&gt;. As a matter of fact, &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ms171468%28v=VS.100%29.aspx&#34;&gt;Visual Studio uses MSBuild behind the scenes&lt;/a&gt; whenever you hit &amp;ldquo;build&amp;rdquo; in the IDE.&lt;/p&gt;

&lt;p&gt;If you open a project file in your favorite text editor you will find a list of &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/t4w159bs.aspx&#34;&gt;&lt;code&gt;PropertyGroup&lt;/code&gt;&lt;/a&gt; elements representing your project&amp;rsquo;s build configurations. Each has an attribute &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/7szfhaft.aspx&#34;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; that serves as an identifier for a group of project-related settings. The unique key used as a condition usually consists of two values: &lt;em&gt;configuration&lt;/em&gt; and &lt;em&gt;platform&lt;/em&gt;, e.g. &lt;code&gt;Debug|x86&lt;/code&gt;. In that PropertyGroup element you may find a child called &lt;code&gt;PlatformTarget&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39;&amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\release&amp;lt;/OutputPath&amp;gt;
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt; 
&amp;lt;/PropertyGroup&amp;gt;
&amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|x86&#39;&amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\x86\debug\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;x86&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
&amp;lt;/PropertyGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The value in &lt;code&gt;PlatformTarget&lt;/code&gt; is what the compiler &lt;em&gt;actually&lt;/em&gt; uses to determine which platform your assembly will be generated for. This gives us the simplest and most direct part of the configuration chain:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PROJ platform target =&amp;gt; Binary
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The condition on the &lt;code&gt;PropertyGroup&lt;/code&gt; element has to evaluate to &lt;code&gt;true&lt;/code&gt; in order for that &lt;code&gt;PlatformTarget&lt;/code&gt; value to be used. They are simple string parameters that get passed into MSBuild as parameters. In the configuration chain, it looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PROJ config + PROJ platform =&amp;gt; PROJ platform target =&amp;gt; Binary
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can build a project file with MSBuild using the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ms229859.aspx&#34;&gt;Visual Studio command prompt&lt;/a&gt;. Alternatively you can call MSBuild directly (for .NET 4 typically &lt;code&gt;C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe&lt;/code&gt;). MSBuild takes parameters to determine which configuration and platform it will use, eventually reading one of those PropertyGroup elements and then doing it&amp;rsquo;s magic.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$&amp;gt; MSBuild &amp;quot;MyProject.csproj&amp;quot; /p:Configuration=&amp;quot;Release&amp;quot; /p:Platform=&amp;quot;Any CPU&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Solution configurations&lt;/h1&gt;

&lt;p&gt;Solution configurations are a different story. While projects are directly related to binaries of your generated application, a solution is not. It is a mere container for projects. And yet, it too has a &amp;ldquo;configuration&amp;rdquo; and a &amp;ldquo;platform&amp;rdquo; setting. You can use MSBuild with the same parameters to build a solution, like you would do with a project. How does this make sense?&lt;/p&gt;

&lt;p&gt;A solution is a &amp;ldquo;meta-project&amp;rdquo;, and it&amp;rsquo;s configuration and platform settings can be described as &amp;ldquo;meta-settings&amp;rdquo;. Visual Studio uses them to tell MSBuild which parameters to use when building each &lt;em&gt;project&lt;/em&gt; within it. The solution holds a list of projects&amp;rsquo; &lt;code&gt;Active Configuration&lt;/code&gt; for each possible combination of solution configuration and solution platform (there&amp;rsquo;s other stuf in there as well, but let&amp;rsquo;s ignore that for now). Whatever combination of &lt;em&gt;solution&lt;/em&gt; configuration and platform you set, that becomes the active configuration, and MSBuild needs to know which &lt;em&gt;project&lt;/em&gt; configuration and solution those map to - for each and every project. That gives us A x B x C active configurations where A: number of projects, B: number of solution configurations and C: number or solution platforms.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{74482536-2654-4B15-B457-9425A05341E6}.Debug|Any CPU.ActiveCfg = Debug|Any CPU 
{74482536-2654-4B15-B457-9425A05341E6}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU 
{74482536-2654-4B15-B457-9425A05341E6}.Debug|x86.ActiveCfg = Debug|Any CPU 
{74482536-2654-4B15-B457-9425A05341E6}.Release|Any CPU.ActiveCfg = Release|Any CPU 
{74482536-2654-4B15-B457-9425A05341E6}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU 
{74482536-2654-4B15-B457-9425A05341E6}.Release|x86.ActiveCfg = Release|Any CPU
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That completes our configuration chain from earlier, which for the record now looks like this again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SLN config + SLN platform =&amp;gt; PROJ config + PROJ platform =&amp;gt; PROJ platform platform =&amp;gt; Binary
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;The Scary Part&lt;/h1&gt;

&lt;p&gt;It is important to understand that the relationship between solution settings and project settings is not as direct as it may seem. Setting the solution to &lt;code&gt;Release|x64&lt;/code&gt; does not necessarily mean you are switching each project to exactly that setting. Visual Studio will constantly keep track of how you configure the project settings and associate them with the currently selected solution settings. VS will update the active configuration accordingly whenever a project&amp;rsquo;s configuration or target platform is modified. Whenever you switch your active configuration, and then make a change to a project&amp;rsquo;s settings, VS stores those as that project&amp;rsquo;s active configuration in the solution file. It is easy to forget that and to unintentionally submit the change into source control.&lt;/p&gt;

&lt;p&gt;Now picture a team of developers, unaware of all this, working in the same solution. Adding new projects, modifying project settings - every once in a while switching platforms. After some time, maybe many months (and many VCS submits) that list of active configurations in the solution file will grow into a mess. The end result is a random mix of assemblies with different architectures.&lt;/p&gt;

&lt;p&gt;If someone builds the solution as &lt;code&gt;Release|Any&lt;/code&gt; CPU she might end up having a wild mix of &lt;em&gt;x86&lt;/em&gt;, &lt;em&gt;x64&lt;/em&gt; and other types of assemblies in the resulting binaries. The user&amp;rsquo;s intention of building a solution as &lt;strong&gt;Any&lt;/strong&gt; CPU is not &amp;ldquo;I don&amp;rsquo;t care what comes out on the other end&amp;rdquo;. It means &amp;ldquo;I want all assemblies to be compiled as &lt;code&gt;Any CPU&lt;/code&gt;, with all advantages and disadvantages&amp;rdquo;. A very big difference!&lt;/p&gt;

&lt;p&gt;It might not show right away when you have a &amp;ldquo;friendly&amp;rdquo; mix of compatible architectures and a little bit of luck, e.g. &lt;code&gt;AnyCPU&lt;/code&gt; and &lt;code&gt;x86&lt;/code&gt; running on a 32bit machine - intended or not, that might go unnoticed most of the time. But as soon as you start mixing incompatible assemblies, you app will go boom at run-time. But sudden death is not the worst thing that can happen; Depending on your code and dependencies, more subtle side-effects can creep in - posing a much bigger threat, since you then have production code running in an unpredictable state.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BadImageFormatException: An attempt was made to load a program with an incorrect format.
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;The Principle of Least Surprise&lt;/h1&gt;

&lt;p&gt;Have a look at your project&amp;rsquo;s solution file. You might discover that some active configurations are not consistent. In some rare special cases you might have good reasons to do things differently, but usually it is best to keep things simple: The solution settings should represent it&amp;rsquo;s projects&amp;rsquo; configurations as directly as possible. Compiling a solution with certain settings should be directly reflected in the generated binaries. I recently heard someone mention &amp;ldquo;the principle of least surprise&amp;rdquo;. That&amp;rsquo;s what this is about. Surprises are for birthday parties and Oprah. What we developers want is control.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Inconsistency in a solution:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;{74482536-2654-4B15-B457-9425A05341E6}.Debug|x86.ActiveCfg = Debug|x64 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Inconsistency in a project:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|x86&#39;&amp;quot;&amp;gt;
  &amp;lt;PlatformTarget&amp;gt;x64&amp;lt;/PlatformTarget&amp;gt;
&amp;lt;/PropertyGroup&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to regain control of your solution build, you will have check the active configuration of every project for each possible combination of solution configuration and platform. Keep in mind that you might want to get rid of unused or unwanted options before doing so, reducing the reconfiguration work that has to be done. If you have many projects, this might take a few hours to get right. You need to make conscious decisions as to how you want which project to build. Knowledge of the project is therefor required and it might mean you have to discuss these decisions with your team.&lt;/p&gt;

&lt;p&gt;The following is my recommended strategy for straightening out your solution and project configurations. I want to emphasize that &lt;strong&gt;this is my personal preference&lt;/strong&gt; and that there may be good reasons to do it differently (e.g. when developing for funky platforms such as Windows Phone or Xbox). I believe this strategy is good for most (if not all) projects, being that it restores predictability and forces you to make decisions on how you want your project to be deployed. Here goes.&lt;/p&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;Regaining Control&lt;/h1&gt;

&lt;p&gt;Open the Configuration Manager. By switching &lt;code&gt;Configuration&lt;/code&gt; and &lt;code&gt;Platform&lt;/code&gt; you will be able to view and modify what project configurations/platforms will be targeted when building the solution in that mode. The general rule of thumb I recommend is to always keep solutions and project settings in sync. If the solution is set to &lt;code&gt;Debug|Any CPU&lt;/code&gt;, then all projects should be as well.&lt;/p&gt;

&lt;p&gt;When setting to a more specific platform such as &lt;code&gt;x86&lt;/code&gt;, you should switch as many projects&amp;rsquo; configurations as possible to that, too - otherwise to &lt;code&gt;Any CPU&lt;/code&gt;. In an ideal world you would set all projects to &lt;code&gt;x86&lt;/code&gt;, and if you can, do so. If you need to leave some &lt;code&gt;Any CPU&lt;/code&gt; projects in that mode (because you are probably just too lazy to do otherwise), at least make sure they are not your apps &amp;ldquo;entry points&amp;rdquo;, i.e. executable projects. The reason is if you build as &lt;code&gt;x86&lt;/code&gt; but your executable is &lt;code&gt;Any CPU&lt;/code&gt;, running the app on a 64bit machine will make your whole app domain run as x64, which is not always desirable and - much worse - not expected. So try to use the exact same config as in the solution whenever possible. Even if it means (some seconds of) extra work adding configurations to projects.&lt;/p&gt;

&lt;figure &gt;
    
    &lt;figcaption&gt;
        &lt;p&gt;
        The *Configuration Manager* window
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
    &lt;p&gt;&lt;a href=&#34;/img/blogger/configmanager.jpeg&#34;&gt;
  &lt;img src=&#34;/img/blogger/configmanager.jpeg&#34;   width=&#34;400em&#34;  /&gt;
  &lt;/a&gt;&lt;/p&gt;

&lt;/figure&gt;

&lt;div class=&#34;clearboth&#34;&gt;&lt;/div&gt;

&lt;p&gt;This topic is harder to explain than it should be, and much harder to describe than it actually is to do. Even if I am beating a dead horse here, I would like to describe the process using an example walk-through. My example app needs special treatment on 64bit platforms, meaning you have to run it explicitly as 32bit in order to support some third-party libraries that will die horribly if in x64 mode. The goal is to have an &lt;code&gt;Any CPU&lt;/code&gt; mode for any machine and an &lt;code&gt;x86&lt;/code&gt; mode in case you need to build an explicit 32bit app for a 64bit environment. Later on you could ditch the &lt;code&gt;x86&lt;/code&gt; mode if the incompatibility is out of the way. Note that if you don&amp;rsquo;t have issues running on 64bit machines, you can do the following while only keeping &lt;code&gt;Any CPU&lt;/code&gt; and can delete every other platform - making things much easier.&lt;/p&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Solution&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;In the Configuration Manager, remove any solution configuration other than &lt;code&gt;Debug&lt;/code&gt; and &lt;code&gt;Release&lt;/code&gt;. Also remove any solution platform other than &lt;code&gt;Any CPU&lt;/code&gt; and &lt;code&gt;x86&lt;/code&gt; (the latter only if you need a build that is never, ever supposed to run in a 64bit context).&lt;/li&gt;
&lt;li&gt;Select Debug and Any CPU in Visual Studio&amp;rsquo;s toolbar menus

&lt;ol&gt;
&lt;li&gt;Below, change &lt;em&gt;every&lt;/em&gt; project&amp;rsquo;s configuration to Debug&lt;/li&gt;
&lt;li&gt;Change &lt;em&gt;every&lt;/em&gt; project&amp;rsquo;s platform to &lt;code&gt;Any CPU&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Check &lt;em&gt;every&lt;/em&gt; project&amp;rsquo;s &lt;em&gt;build&lt;/em&gt; check-box. That will ensure they recompile properly whenever you switch configurations. Otherwise, switching and then building could result in mixed-platform assemblies (= bad)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Select &lt;code&gt;Release&lt;/code&gt; and &lt;code&gt;Any CPU&lt;/code&gt;

&lt;ol&gt;
&lt;li&gt;Below, change &lt;em&gt;every&lt;/em&gt; project&amp;rsquo;s configuration to &lt;code&gt;Release&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;same as 2.2&lt;/li&gt;
&lt;li&gt;same as 2.3&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;select &lt;code&gt;Debug&lt;/code&gt; and &lt;code&gt;x86&lt;/code&gt;

&lt;ol&gt;
&lt;li&gt;same as 2.1&lt;/li&gt;
&lt;li&gt;Change &lt;em&gt;every&lt;/em&gt; project&amp;rsquo;s target platform to &lt;code&gt;x86&lt;/code&gt;. If x86 is not an available platform for some projects, create them. At the very minimum, &lt;em&gt;every executable project must be x86&lt;/em&gt;; others usually can be &lt;code&gt;Any CPU&lt;/code&gt; if they really need to be, but for the sake of predictability, try to avoid that.&lt;/li&gt;
&lt;li&gt;same as 2.3&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Select &lt;code&gt;Release&lt;/code&gt; and &lt;code&gt;x86&lt;/code&gt;

&lt;ol&gt;
&lt;li&gt;same as 2.1&lt;/li&gt;
&lt;li&gt;Change &lt;em&gt;every&lt;/em&gt; project&amp;rsquo;s platform to &lt;code&gt;x86&lt;/code&gt;. As explained in 4.2, try to avoid anything else, even &lt;code&gt;Any CPU&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;same as 2.3&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_9&#34;&gt;&lt;em&gt;Every&lt;/em&gt; project&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Open the project designer window (&amp;ldquo;project settings&amp;rdquo;) and go to the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/kb4wyys2.aspx&#34;&gt;build page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Remove any configurations and platforms that &lt;a href=&#34;http://www.xprogramming.com/Practices/PracNotNeed.html&#34;&gt;you do not need&lt;/a&gt; to avoid accidentally using the (now) deprecated settings in the future&lt;/li&gt;
&lt;li&gt;Select &lt;code&gt;Debug&lt;/code&gt; and &lt;code&gt;Any CPU&lt;/code&gt; project settings at the top of the window

&lt;ol&gt;
&lt;li&gt;Set the &lt;em&gt;platform target&lt;/em&gt; in the middle of the window to be &lt;code&gt;Any CPU&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Select &lt;code&gt;Debug&lt;/code&gt; and &lt;code&gt;x86&lt;/code&gt;

&lt;ol&gt;
&lt;li&gt;Set the platform target to &lt;code&gt;x86&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Select &lt;code&gt;Release&lt;/code&gt; and &lt;code&gt;Any CPU&lt;/code&gt;

&lt;ol&gt;
&lt;li&gt;Set the platform target to &lt;code&gt;Any CPU&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Select &lt;code&gt;Release&lt;/code&gt; and &lt;code&gt;x86&lt;/code&gt;

&lt;ol&gt;
&lt;li&gt;Set the platform target to &lt;code&gt;x86&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&amp;hellip; I think you get the idea. Rinse and repeat for any other combination of solution configuration and platform. The general purpose is to take out some of the variables in the configuration chain and (pretend) it looks like what you would expect:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SLN config + SLN platform =&amp;gt; PROJ config + PROJ platform =&amp;gt; PROJ platform platform =&amp;gt; Binary
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_10&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Before I wrap this up you should know why I wrote this (probably too long) post in the first place. Recently I was running into those &lt;code&gt;BadImageFormatExceptions&lt;/code&gt; on a CI build server. It turned out that some of the projects compiled to x64, despite passing in explicit &lt;code&gt;Release|x86&lt;/code&gt; into the solution build. The CI servers are 32bit machines, and they crashed when a unit test attempted to load a 64bit assembly. Did I mention that I &lt;em&gt;really&lt;/em&gt; like unit tests?&lt;/p&gt;

&lt;p&gt;One nice effect of cleaning this up was that it reduced the solution&amp;rsquo;s file size enormously. From a whopping 4500 lines to less than 1500 lines - just by dumping unused configurations. I have not verified this yet, but I expect loading the solution and switching configurations to be (at least slightly) faster now. After all, VS loads that file into memory and works with it every time you switch.&lt;/p&gt;

&lt;p&gt;For what it&amp;rsquo;s worth, I think this is way too hard to control in Visual Studio. There is much flexibility here that is usually not required and only gets abused, consciously or not. The only thing a developer should have to worry about are the toolbar menus for solution configuration and platform. I find that the latter seems to disappear on some machines after a while. It would be wise to &lt;a href=&#34;http://blogs.msdn.com/b/nicgrave/archive/2010/06/19/platform-and-configuration-selection-in-visual-studio-2010-express-for-windows-phone.aspx&#34;&gt;re-activate&lt;/a&gt; it, so you are constantly aware of  which platform you have selected. That will help avoid producing absurd active configuration constellations in the solution. Another best practice would be: always diff on your solution and project files before submitting them to source control. Understand what has changed and make sure it does not conflict with the intended configurations for your project.&lt;/p&gt;

&lt;p&gt;I apologize if this post seemed repetitive at times. The terminology around these &amp;ldquo;configurations&amp;rdquo; and &amp;ldquo;platforms&amp;rdquo; is redundant and confusing, but once you got a grasp of these settings and the importance for your app (and your sanity!) you should have a much better understanding of how VS produces your application - and have much more control over the process.&lt;/p&gt;

&lt;h1 id=&#34;toc_11&#34;&gt;Resources&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/kkz9kefa%28v=VS.100%29.aspx&#34;&gt;MSDN on solution and project configuration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ms164311.aspx&#34;&gt;MSBuild command line reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/5dy88c2e.aspx&#34;&gt;Project file schema reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blogs.msdn.com/b/nicgrave/archive/2010/06/19/platform-and-configuration-selection-in-visual-studio-2010-express-for-windows-phone.aspx&#34;&gt;How to: Enable the solution platform selector&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/kwybya3w.aspx&#34;&gt;How to: Create and Edit Configurations&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>